import Jimp from "jimp"; export type PreOpts={ deskew?:boolean; binarize?:boolean; blurRadius?:number; invert?:boolean; }; function toGray(img:Jimp){ img.grayscale(); } function blur(img:Jimp,r:number){ if(r&&r>0) img.blur(Math.max(1,Math.min(10,Math.floor(r)))); } function otsuThreshold(hist:number[],total:number):number{ let sum=0; for(let i=0;i<256;i++) sum+=i*hist[i]; let sumB=0,wB=0,wF=0,varMax=0,thr=127; for(let t=0;t<256;t++){ wB+=hist[t]; if(wB===0) continue; wF=total-wB; if(wF===0) break; sumB+=t*hist[t]; const mB=sumB/wB; const mF=(sum-sumB)/wF; const v=wB*wF*(mB-mF)*(mB-mF); if(v>varMax){ varMax=v; thr=t; } } return thr; } async function binarize(img:Jimp){ const { data,width,height }=img.bitmap as any; const hist=new Array(256).fill(0); for(let i=0;i<data.length;i+=4){ const v=data[i]; hist[v]++; } const total=width*height; const thr=otsuThreshold(hist,total); for(let i=0;i<data.length;i+=4){ const v=data[i]>=thr?255:0; data[i]=data[i+1]=data[i+2]=v; } } function scoreVerticalProjection(img:Jimp){ const { data,width,height }=img.bitmap as any; const colSum=new Array(width).fill(0); for(let y=0;y<height;y++){ for(let x=0;x<width;x++){ const idx=(width*y+x)*4; colSum[x]+=255-data[idx]; } } let varSum=0,mean=0; for(const c of colSum) mean+=c; mean/=width; for(const c of colSum){ const d=c-mean; varSum+=d*d; } return varSum/width; } async function deskew(img:Jimp){ const rad=(deg:number)=>deg*Math.PI/180; let bestScore=-1,bestAngle=0; const base=img.clone(); for(let a=-6;a<=6;a+=0.5){ const rotated=base.clone().rotate(a,false); const s=scoreVerticalProjection(rotated); if(s>bestScore){ bestScore=s; bestAngle=a; } } if(bestAngle!==0){ img.rotate(bestAngle,false); } } export async function preprocessImageBuffer(buf:Buffer,opts:PreOpts={}):Promise<Buffer>{ const img=await Jimp.read(buf); toGray(img); if(opts.blurRadius) blur(img,opts.blurRadius); if(opts.deskew) await deskew(img); if(opts.binarize) await binarize(img); if(opts.invert) img.invert(); return await img.getBufferAsync(Jimp.MIME_PNG); }
export { ocrAndNormalizeImage, ocrAndNormalizePdf, normalizeSpanishText } from "./norm-index.js";
export { preprocessImageBuffer } from "./preprocess.js";
{ "name": "@iberitax/ocr", "version": "0.1.0", "type": "module", "main": "dist/index.js", "types": "dist/index.d.ts", "files": ["dist","bin"], "scripts": { "build": "tsc -p tsconfig.json" }, "dependencies": { "jimp": "^0.22.12", "tesseract.js": "^5.1.0" } }
import fs from "node:fs"; import { ocrBuffer } from "../packages/ocr/dist/index.js"; const buf = fs.readFileSync("tests/fixtures/ocr/hola.png"); ocrBuffer(buf,{lang:"spa"}).then(t=>{ console.log(t.trim()); if(!t.toLowerCase().includes("hola")){ process.exitCode=1; } }).catch(e=>{ console.error(e); process.exitCode=1; });
